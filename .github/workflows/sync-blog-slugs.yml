name: Sync Blog Filenames with Slugs

on:
  push:
    paths:
      - 'content/blog/*.mdx'
    branches:
      - main

jobs:
  sync-slugs:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for duplicate slugs
        id: check_duplicates
        run: |
          cd content/blog

          # Extract all slugs and check for duplicates
          declare -A slug_files
          has_duplicate=false

          for file in *.mdx; do
            [ -f "$file" ] || continue

            slug=$(sed -n '/^---$/,/^---$/p' "$file" | grep -m1 "^slug:" | sed 's/^slug:[[:space:]]*//' | tr -d "\"'" | tr -d '[:space:]')

            if [ -n "$slug" ]; then
              if [ -n "${slug_files[$slug]}" ]; then
                has_duplicate=true
                echo "::error::DUPLICATE SLUG DETECTED: '$slug' is used by both '${slug_files[$slug]}' and '$file'"
              else
                slug_files[$slug]="$file"
              fi
            fi
          done

          if [ "$has_duplicate" = true ]; then
            echo "Please ensure each blog post has a unique slug."
            exit 1
          fi

          echo "No duplicate slugs found."

      - name: Sync filenames with slugs
        id: sync
        run: |
          cd content/blog
          renamed=false
          has_error=false

          # Initialize redirects.json if it doesn't exist
          if [ ! -f "redirects.json" ]; then
            echo "{}" > redirects.json
          fi

          for file in *.mdx; do
            [ -f "$file" ] || continue

            # Extract slug from frontmatter (handles both quoted and unquoted)
            slug=$(sed -n '/^---$/,/^---$/p' "$file" | grep -m1 "^slug:" | sed 's/^slug:[[:space:]]*//' | tr -d "\"'" | tr -d '[:space:]')

            if [ -n "$slug" ]; then
              filename="${file%.mdx}"

              if [ "$filename" != "$slug" ]; then
                target_file="${slug}.mdx"

                # Check if target file already exists (duplicate slug error)
                if [ -f "$target_file" ]; then
                  has_error=true
                  echo "::error::Cannot rename '$file' to '$target_file' - a file with slug '$slug' already exists!"
                else
                  echo "Renaming: $file -> $target_file"
                  echo "Adding redirect: $filename -> $slug"

                  # Update redirects.json using jq
                  # 1. Add new redirect
                  # 2. Update any existing redirects pointing to old slug
                  jq --arg old "$filename" --arg new "$slug" '
                    .[$old] = $new |
                    to_entries |
                    map(if .value == $old then .value = $new else . end) |
                    from_entries
                  ' redirects.json > redirects.tmp && mv redirects.tmp redirects.json

                  git mv "$file" "$target_file"
                  renamed=true
                fi
              fi
            fi
          done

          # Fail the workflow if there were duplicate slug errors
          if [ "$has_error" = true ]; then
            echo "Please use a different slug - another blog post already uses this URL."
            exit 1
          fi

          echo "renamed=$renamed" >> $GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.sync.outputs.renamed == 'true'
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add -A content/blog/
          git commit -m "Auto-rename blog files to match custom slugs"
          git push
